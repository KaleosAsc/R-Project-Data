"bad", "terrible", "disappointed", "problem", "issue", "broken", "slow",
"update", "feature", "service", "support", "interface", "design", "experience",
"download", "install", "upgrade", "bug", "error", "crash", "fix", "solution"
)
library(readr)
library(dplyr)
library(httr)
library(jsonlite)
library(purrr)
library(rlang)
library(cld2)
library(dotenv)
Copia_Datos_Limpios$is_duplicated <-
duplicated(Copia_Datos_Limpios$translated) |
duplicated(Copia_Datos_Limpios$translated, fromLast = TRUE)
Copia_Datos_Limpios$spam_verified <- ifelse(Copia_Datos_Limpios$is_duplicated, "spam", "ham")
View(Copia_Datos_Limpios)
# Bolsa de palabras válidas para reseñas
valid_words <- c(
"great", "good", "excellent", "amazing", "love", "helpful", "easy", "fast",
"quality", "recommend", "happy", "satisfied", "improved", "useful", "perfect",
"bad", "terrible", "disappointed", "problem", "issue", "broken", "slow",
"update", "feature", "service", "support", "interface", "design", "experience",
"download", "install", "upgrade", "bug", "error", "crash", "fix", "solution"
)
# Función para evaluar si un texto es válido
is_valid_review <- function(text) {
# Manejar valores nulos o vacíos
if (is.na(text) || text == "" || nchar(trimws(text)) == 0) {
return(FALSE) # Texto vacío o nulo no es válido
}
# Convertir el texto a minúsculas para hacer la comparación insensible a mayúsculas/minúsculas
text_lower <- tolower(as.character(text))
# Verificar si alguna palabra válida aparece en el texto
has_valid_word <- any(sapply(valid_words, function(word) grepl(paste0("\\b", word, "\\b"), text_lower)))
return(has_valid_word)
}
Copia_Datos_Limpios <- Copia_Datos_Limpios %>%
mutate(
spam_verified = case_when(
spam_verified != "spam" &
detect_language(translated) == "en" &
is_valid_review(translated) ~ "ham", # Ham si no es spam, está en inglés y contiene palabras válidas
spam_verified != "spam" &
detect_language(translated) == "en" &
!is_valid_review(translated) ~ "spam", # Spam si no es spam, está en inglés pero no contiene palabras válidas
TRUE ~ spam_verified # Mantener el valor original si no se cumplen las condiciones anteriores
)
)
# Función corregida y vectorizada para evaluar si un texto es válido
is_valid_review <- function(text) {
# Asegurarse de que sea carácter
text <- as.character(text)
# Reemplazar NA por cadena vacía para evitar errores
text[is.na(text)] <- ""
# Eliminar espacios y pasar a minúsculas
text <- tolower(trimws(text))
# Texto vacío → FALSE
empty <- nchar(text) == 0
# Crear un solo patrón con todas las palabras válidas
pattern <- paste0("\\b(", paste(valid_words, collapse = "|"), ")\\b")
# Detectar si contiene alguna palabra válida
has_valid_word <- grepl(pattern, text)
# Resultado final
result <- !empty & has_valid_word
return(result)
}
# Evaluación del dataset
Copia_Datos_Limpios <- Copia_Datos_Limpios %>%
mutate(
spam_verified = case_when(
spam_verified != "spam" &
detect_language(translated) == "en" &
is_valid_review(translated) ~ "ham",
spam_verified != "spam" &
detect_language(translated) == "en" &
!is_valid_review(translated) ~ "spam",
TRUE ~ spam_verified
)
)
# Función corregida para detectar idioma (vectorizada)
detect_language <- function(text) {
# Asegurarse de que sea texto
text <- as.character(text)
# Reemplazar NA por vacío
text[is.na(text)] <- ""
# Si está vacío, asignar NA como idioma
empty <- nchar(trimws(text)) == 0
result <- rep(NA_character_, length(text))
# Solo detectar idioma donde haya texto
if (any(!empty)) {
result[!empty] <- cld2::detect_language(text[!empty])
}
return(result)
}
# Evaluación del dataset
Copia_Datos_Limpios <- Copia_Datos_Limpios %>%
mutate(
spam_verified = case_when(
spam_verified != "spam" &
detect_language(translated) == "en" &
is_valid_review(translated) ~ "ham",
spam_verified != "spam" &
detect_language(translated) == "en" &
!is_valid_review(translated) ~ "spam",
TRUE ~ spam_verified
)
)
View(Copia_Datos_Limpios)
Copia_Datos_Limpios <- Copia_Datos_Limpios %>%
select(-is_duplicated, -spam_verified)
View(Copia_Datos_Limpios)
View(detect_language)
# Bolsa de palabras válidas para reseñas
valid_words <- c(
"great", "good", "excellent", "amazing", "love", "helpful", "easy", "fast",
"quality", "recommend", "happy", "satisfied", "improved", "useful", "perfect",
"bad", "terrible", "disappointed", "problem", "issue", "broken", "slow",
"update", "feature", "service", "support", "interface", "design", "experience",
"download", "install", "upgrade", "bug", "error", "crash", "fix", "solution"
)
# Función para obtener el idioma típico de un país
get_language_from_country <- function(country) {
# Mapeo de países a códigos de idioma (basado en tu lista)
country_to_language <- c(
"China" = "zh-Hans",          # Chino simplificado
"Russia" = "ru",              # Ruso
"Spain" = "es",               # Español
"India" = "hi",               # Hindi (también podría ser "en" si se usa inglés comúnmente)
"South Korea" = "ko",         # Coreano
"Australia" = "en",           # Inglés
"Japan" = "ja",               # Japonés
"France" = "fr",              # Francés
"Italy" = "it",               # Italiano
"Germany" = "de",             # Alemán
"Vietnam" = "vi",             # Vietnamita
"Turkey" = "tr",              # Turco
"Thailand" = "th",            # Tailandés
"Brazil" = "pt",              # Portugués
"Nigeria" = "en",             # Inglés (oficial y ampliamente usado)
"United States" = "en",       # Inglés
"Bangladesh" = "bn",          # Bengalí
"Canada" = "en",              # Inglés (también podría ser "fr" para francés en Quebec)
"Indonesia" = "id",           # Indonesio
"Mexico" = "es",              # Español
"Malaysia" = "ms",            # Malayo
"Pakistan" = "ur",            # Urdu (también podría ser "en" si se usa inglés comúnmente)
"Philippines" = "fil",        # Filipino
"United Kingdom" = "en"       # Inglés
)
# Devolver el idioma correspondiente al país
return(country_to_language[country])
}
# Función corregida para detectar idioma (vectorizada)
detect_language <- function(text) {
# Asegurarse de que sea texto
text <- as.character(text)
# Reemplazar NA por vacío
text[is.na(text)] <- ""
# Si está vacío, asignar NA como idioma
empty <- nchar(trimws(text)) == 0
result <- rep(NA_character_, length(text))
# Solo detectar idioma donde haya texto
if (any(!empty)) {
result[!empty] <- cld2::detect_language(text[!empty])
}
return(result)
}
# Función corregida y vectorizada para evaluar si un texto es válido
is_valid_review <- function(text) {
# Asegurarse de que sea carácter
text <- as.character(text)
# Reemplazar NA por cadena vacía para evitar errores
text[is.na(text)] <- ""
# Eliminar espacios y pasar a minúsculas
text <- tolower(trimws(text))
# Texto vacío → FALSE
empty <- nchar(text) == 0
# Crear un solo patrón con todas las palabras válidas
pattern <- paste0("\\b(", paste(valid_words, collapse = "|"), ")\\b")
# Detectar si contiene alguna palabra válida
has_valid_word <- grepl(pattern, text)
# Resultado final
result <- !empty & has_valid_word
return(result)
}
# Bolsa de palabras válidas para reseñas
valid_words <- c(
"great", "good", "excellent", "amazing", "love", "helpful", "easy", "fast",
"quality", "recommend", "happy", "satisfied", "improved", "useful", "perfect",
"bad", "terrible", "disappointed", "problem", "issue", "broken", "slow",
"update", "feature", "service", "support", "interface", "design", "experience",
"download", "install", "upgrade", "bug", "error", "crash", "fix", "solution"
)
# Evaluación del dataset
Copia_Datos_Limpios <- Copia_Datos_Limpios %>%
mutate(
spam_verified = case_when(
spam_verified != "spam" &
detect_language(translated) == "en" &
is_valid_review(translated) ~ "ham",
spam_verified != "spam" &
detect_language(translated) == "en" &
!is_valid_review(translated) ~ "spam",
TRUE ~ spam_verified
)
)
# Evaluación del dataset
# Evaluación del dataset
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios %>%
mutate(
spam_flag = case_when(
detect_language(translated) == "en" & is_valid_review(translated) ~ "ham",
detect_language(translated) == "en" & !is_valid_review(translated) ~ "spam",
TRUE ~ NA_character_  # si no está en inglés o no aplica
)
)
View(Copia_Datos_Limpios_classified)
## Función para detectar si un texto es latín (vectorizada)
is_latin <- function(text) {
# Manejar valores nulos o vacíos (vectorizado)
if (all(is.na(text)) || all(text == "") || all(nchar(trimws(text)) == 0)) {
return(rep(FALSE, length(text))) # Devolver un vector de FALSE del mismo tamaño
}
# Lista de palabras clave y sufijos típicos del latín
latin_keywords <- c(
"quis", "doloribus", "consequuntur", "perspiciatis",
"tempora", "assumenda", "atque", "doloremque",
"nobis", "voluptatem", "quidem", "esse"
)
latin_suffixes <- c(
"us", "is", "um", "ae", "am", "ibus", "i", "o"
)
# Convertir el texto a minúsculas para hacer la comparación insensible a mayúsculas/minúsculas
text_lower <- tolower(as.character(text))
# Verificar si alguna palabra clave aparece en el texto (vectorizado)
has_keywords <- sapply(text_lower, function(txt) {
any(sapply(latin_keywords, function(kw) grepl(kw, txt)))
})
# Verificar si el texto contiene sufijos típicos del latín (vectorizado)
has_suffixes <- sapply(text_lower, function(txt) {
any(sapply(latin_suffixes, function(suffix) grepl(paste0("\\b\\w*", suffix, "\\b"), txt)))
})
# Combinar las condiciones (vectorizado)
return(has_keywords | has_suffixes)
}
Copia_Datos_Limpios <- Copia_Datos_Limpios %>%
mutate(
spam_flag = case_when(
spam_flag == "ham" & is_latin(review_text) ~ "spam", # Marcar como spam si es latín
TRUE ~ spam_flag # Mantener el valor original si no se cumplen las condiciones
)
)
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios_classified %>%
mutate(
spam_flag = case_when(
spam_flag == "ham" & is_latin(review_text) ~ "spam", # Marcar como spam si es latín
TRUE ~ spam_flag # Mantener el valor original si no se cumplen las condiciones
)
)
View(Copia_Datos_Limpios_classified)
unique(Copia_Datos_Limpios$spam_verified)
values_verified <- Copia_Datos_Limpios %>% filter(spam_verified == "ham")
unique(Copia_Datos_Limpios$spam_verified)
values_verified <- Copia_Datos_Limpios %>% filter(spam_flag == "ham")
unique(Copia_Datos_Limpios_classified$spam_verified)
values_verified <- Copia_Datos_Limpios_classified %>% filter(spam_flag == "ham")
View(values_verified)
# Crear la variable spam_flag según duplicados en 'translated'
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios_classified %>%
mutate(
spam_flag = ifelse(
duplicated(translated) | duplicated(translated, fromLast = TRUE),
"spam",
"ham"
)
)
unique(Copia_Datos_Limpios_classified$spam_verified)
values_verified <- Copia_Datos_Limpios_classified %>% filter(spam_flag == "ham")
View(values_verified)
View(Copia_Datos_Limpios_classified)
View(Copia_Datos_Limpios)
View(Copia_Datos_Limpios_classified)
print(Copia_Datos_Limpios_classified)
Copia_Datos_Limpios_lorem <- Copia_Datos_Limpios %>%
filter(!is.na(detect_language(review_text))) %>%
filter(detect_language(review_text) %in% c("en", "es"))
View(Copia_Datos_Limpios_lorem)
View(Copia_Datos_Limpios_lorem)
Copia_Datos_Limpios_lorem <- Copia_Datos_Limpios %>%
# Detectar idioma solo una vez para evitar recalcular
mutate(lang = detect_language(review_text)) %>%
# Mantener solo los textos válidos:
filter(
# Caso 1: idioma inglés o español → lo conservamos
lang %in% c("en", "es") |
# Caso 2: texto diferente al traducido (sí fue traducido) → lo conservamos
review_text != translated
) %>%
# Eliminar columna auxiliar
select(-lang)
View(Copia_Datos_Limpios_lorem)
detect_language("Dicta harum laboriosam dolores nemo.")
View(detect_language)
detect_language <- function(text) {
# Asegurarse de que sea texto
text <- as.character(text)
text[is.na(text)] <- ""
# Si está vacío, asignar NA
empty <- nchar(trimws(text)) == 0
result <- rep(NA_character_, length(text))
# Detectar idioma solo donde haya texto
if (any(!empty)) {
result[!empty] <- cld2::detect_language(text[!empty])
}
# Detectar patrones de Lorem Ipsum
lorem_pattern <- "(?i)\\blorem\\b|\\bipsum\\b|\\bdolor\\b|\\bamet\\b|\\bconsectetur\\b|\\badipiscing\\b|\\belit\\b|\\btempor\\b|\\blabore\\b|\\bnemo\\b|\\bhic\\b|\\bunde\\b|\\bvoluptate\\b"
# Si contiene palabras típicas de Lorem Ipsum, marcar como 'la' (latín simulado)
result[grepl(lorem_pattern, text)] <- "la"
return(result)
}
detect_language("Dicta harum laboriosam dolores nemo.")
Copia_Datos_Limpios_lorem <- Copia_Datos_Limpios %>%
# Detectar idioma solo una vez para evitar recalcular
mutate(lang = detect_language(review_text)) %>%
# Mantener solo los textos válidos:
filter(
# Caso 1: idioma inglés o español → lo conservamos
lang %in% c("en", "es") |
# Caso 2: texto diferente al traducido (sí fue traducido) → lo conservamos
review_text != translated
) %>%
# Eliminar columna auxiliar
select(-lang)
View(Copia_Datos_Limpios_lorem)
detect_language("Commodi facilis suscipit quia tempora. Excepturi deleniti por")
View(detect_language)
detect_language <- function(text) {
# Asegurarse de que sea texto
text <- as.character(text)
text[is.na(text)] <- ""
# Si está vacío, asignar NA
empty <- nchar(trimws(text)) == 0
result <- rep(NA_character_, length(text))
# Detectar idioma solo donde haya texto
if (any(!empty)) {
result[!empty] <- cld2::detect_language(text[!empty])
}
# Detectar patrones típicos de Lorem Ipsum
lorem_pattern <- "(?i)\\blorem\\b|\\bipsum\\b|\\bdolor\\b|\\bamet\\b|\\bconsectetur\\b|\\badipiscing\\b|\\belit\\b|\\btempor\\b|\\blabore\\b|\\bnemo\\b|\\bhic\\b|\\bunde\\b|\\bvoluptate\\b|\\bcommodi\\b|\\bfacilis\\b|\\bsuscipit\\b|\\bquia\\b|\\btempora\\b|\\bexcepturi\\b|\\bdeleniti\\b"
# Marcar como 'la' si contiene palabras de Lorem Ipsum
result[grepl(lorem_pattern, text)] <- "la"
# Reemplazar NAs (no detectados) también por 'la'
result[is.na(result)] <- "la"
return(result)
}
Copia_Datos_Limpios_lorem <- Copia_Datos_Limpios %>%
# Detectar idioma solo una vez para evitar recalcular
mutate(lang = detect_language(review_text)) %>%
# Mantener solo los textos válidos:
filter(
# Caso 1: idioma inglés o español → lo conservamos
lang %in% c("en", "es") |
# Caso 2: texto diferente al traducido (sí fue traducido) → lo conservamos
review_text != translated
) %>%
# Eliminar columna auxiliar
select(-lang)
View(Copia_Datos_Limpios_lorem)
detect_language("Ratione nisi eius voluptates. Molestiae reiciendis beatae sint.")
Copia_Datos_Limpios_lorem <- Copia_Datos_Limpios %>%
# Detectar idioma una sola vez
mutate(lang = detect_language(review_text)) %>%
# Mantener solo textos válidos
filter(
# Caso 1: idioma inglés o español
lang %in% c("en", "es") |
# Caso 2: texto fue traducido (no es igual al original)
review_text != translated
) %>%
# Excluir explícitamente los detectados como 'la' (latin/lorem)
filter(lang != "la") %>%
# Eliminar columna auxiliar
select(-lang)
View(Copia_Datos_Limpios_lorem)
detect_language("Ex quasi officia quaerat. Qui ratione necessitatibus.")
View(is_latin)
View(detect_language)
is_latin <- function(text) {
# Asegurarse de que sea texto
text <- as.character(text)
text[is.na(text)] <- ""
# Detectar idioma usando la función anterior
detected_lang <- detect_language(text)
# Lista de palabras clave y sufijos típicos del latín
latin_keywords <- c(
"quis", "doloribus", "consequuntur", "perspiciatis",
"tempora", "assumenda", "atque", "doloremque",
"nobis", "voluptatem", "quidem", "esse"
)
latin_suffixes <- c("us", "is", "um", "ae", "am", "ibus", "i", "o")
# Convertir texto a minúsculas
text_lower <- tolower(text)
# Buscar palabras y sufijos latinos
has_keywords <- sapply(text_lower, function(txt) any(sapply(latin_keywords, grepl, txt)))
has_suffixes <- sapply(text_lower, function(txt) any(sapply(latin_suffixes, function(s) grepl(paste0("\\b\\w*", s, "\\b"), txt))))
# Marcar TRUE si el idioma detectado fue 'la' o si cumple los patrones
return(detected_lang == "la" | has_keywords | has_suffixes)
}
rm(Copia_Datos_Limpios_lorem, Copia_Datos_Limpios_classified)
# Bolsa de palabras válidas para reseñas
valid_words <- c(
"great", "good", "excellent", "amazing", "love", "helpful", "easy", "fast",
"quality", "recommend", "happy", "satisfied", "improved", "useful", "perfect",
"bad", "terrible", "disappointed", "problem", "issue", "broken", "slow",
"update", "feature", "service", "support", "interface", "design", "experience",
"download", "install", "upgrade", "bug", "error", "crash", "fix", "solution"
)
View(is_valid_review)
is_latin <- function(text) {
# Asegurarse de que sea texto
text <- as.character(text)
text[is.na(text)] <- ""
# Detectar idioma usando la función anterior
detected_lang <- detect_language(text)
# Lista de palabras clave y sufijos típicos del latín
latin_keywords <- c(
"quis", "doloribus", "consequuntur", "perspiciatis",
"tempora", "assumenda", "atque", "doloremque",
"nobis", "voluptatem", "quidem", "esse"
)
latin_suffixes <- c("us", "is", "um", "ae", "am", "ibus", "i", "o")
# Convertir texto a minúsculas
text_lower <- tolower(text)
# Buscar palabras y sufijos latinos
has_keywords <- sapply(text_lower, function(txt) any(sapply(latin_keywords, grepl, txt)))
has_suffixes <- sapply(text_lower, function(txt) any(sapply(latin_suffixes, function(s) grepl(paste0("\\b\\w*", s, "\\b"), txt))))
# Marcar TRUE si el idioma detectado fue 'la' o si cumple los patrones
return(detected_lang == "la" | has_keywords | has_suffixes)
}
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios %>%
mutate(
spam_flag = case_when(
spam_flag == "ham" & is_latin(review_text) ~ "spam", # Marcar como spam si es latín
TRUE ~ spam_flag # Mantener el valor original si no se cumplen las condiciones
)
)
# Evaluación del dataset
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios %>%
mutate(
spam_flag = case_when(
detect_language(translated) == "en" & is_valid_review(translated) ~ "ham",   # inglés y válido
detect_language(translated) == "en" & !is_valid_review(translated) ~ "spam", # inglés pero no válido
TRUE ~ "spam"  # todo lo demás (no inglés, NA, etc.) se marca como spam
)
)
View(Copia_Datos_Limpios_classified)
unique(Copia_Datos_Limpios_classified$spam_verified)
values_verified <- Copia_Datos_Limpios_classified %>% filter(spam_flag == "ham")
View(values_verified)
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios_classified %>%
mutate(
spam_flag = case_when(
spam_flag == "ham" & is_latin(review_text) ~ "spam", # Marcar como spam si es latín
TRUE ~ spam_flag # Mantener el valor original si no se cumplen las condiciones
)
)
unique(Copia_Datos_Limpios_classified$spam_verified)
values_verified <- Copia_Datos_Limpios_classified %>% filter(spam_flag == "ham")
View(values_verified)
View(Copia_Datos_Limpios_classified)
# Crear la variable spam_flag según duplicados en 'translated'
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios_classified %>%
mutate(
spam_flag = ifelse(
duplicated(translated) | duplicated(translated, fromLast = TRUE),
"spam",
"ham"
)
)
unique(Copia_Datos_Limpios_classified$spam_verified)
values_verified <- Copia_Datos_Limpios_classified %>% filter(spam_flag == "ham")
View(values_verified)
rm(Copia_Datos_Limpios_lorem, Copia_Datos_Limpios_classified)
rm(Copia_Datos_Limpios_classified)
# Evaluación del dataset
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios %>%
mutate(
spam_flag = case_when(
detect_language(translated) == "en" & is_valid_review(translated) ~ "ham",   # inglés y válido
detect_language(translated) == "en" & !is_valid_review(translated) ~ "spam", # inglés pero no válido
TRUE ~ "spam"  # todo lo demás (no inglés, NA, etc.) se marca como spam
)
)
Copia_Datos_Limpios_classified <- Copia_Datos_Limpios_classified %>%
mutate(
spam_flag = case_when(
spam_flag == "ham" & is_latin(review_text) ~ "spam", # Marcar como spam si es latín
TRUE ~ spam_flag # Mantener el valor original si no se cumplen las condiciones
)
)
unique(Copia_Datos_Limpios_classified$spam_verified)
values_verified <- Copia_Datos_Limpios_classified %>% filter(spam_flag == "ham")
View(values_verified)
View(Copia_Datos_Limpios_classified)
multilingual_mobile_app_reviews_2025 <- read_csv("multilingual_mobile_app_reviews_2025_extended.csv")
View(multilingual_mobile_app_reviews_2025)
rm(Copia_Datos_Limpios_classified, multilingual_mobile_app_reviews_2025_extended)
multilingual_mobile_app_reviews_2025 <- read_csv("multilingual_mobile_app_reviews_2025_extended.csv")
View(multilingual_mobile_app_reviews_2025_extended)
multilingual_mobile_app_reviews_2025 <- read_csv("multilingual_mobile_app_reviews_2025_extended.csv")
View(multilingual_mobile_app_reviews_2025)
